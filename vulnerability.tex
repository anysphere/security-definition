\section{The PIR Replay Attack}
\label{sec:security-vulnerable}

In this section, we present the \textit{PIR replay attack} mentioned in the introduction. While the CF attacks in \cite{angel2018cf} can only directly reveal the number of friends each honest user has, the PIR replay attack can potentially directly reveal sender-recipient relationships, if the recipient has a compromised friend. The vulnerability affects existing implementations of both Pung and Addra.

Most PIR schemes (such as SealPIR \cite{angel2018pir}, MulPIR \cite{ali2021communicationcomputation}, FastPIR \cite{ahmad2021addra}, and Spiral \cite{wu2022spiral}) use an underlying homomorphic public key cryptosystem, typically some variation of the BFV cryptosystem \cite{fan2012somewhat}. Generating the necessary keypairs in these cryptosystems is expensive. To improve performance, real-world implementations of FastPIR\footnote{As of 08/31/2022, the following code reuses PIR keys: \url{https://github.com/ishtiyaque/FastPIR/tree/d50b1ba4ad4de64181bce71bccd352798dfa2bb3}} and Spiral\footnote{As of 08/31/2022, the following code reuses PIR keys: \url{https://github.com/menonsamir/spiral-rs/tree/0f9bdc157086ea9534f70bb7d9e7f19920663e84}} reuse PIR keys. Each client generates a secret $\sk_{\pir}$ once and use them to encrypt all PIR queries $\ct = \query(1^{\lambda}, \sk_{\pir}, i)$. This optimization was regarded safe since it preserves the UO-ER security definition in \cite[Extended Version]{angel2016unobservable}. We show how to combine this optimization with a compromised friend to leak metadata.

Suppose the adversary suspects that honest users $A$ and $B$ are communicating, and honest user $A$ has a compromised friend $C$. On timestep $T_0$, user $A$ sends a PIR request $\ct$ to the server. The adversary wishes to know if $\ct$ is a query to honest user $B$'s mailbox at index $i_B$. Assume that
\begin{itemize}
    \item user $A$ will have a conversation with user $C$ at a future time $T_1 > T_0$,
    \item user $A$ does not switch their PIR key pair between time $T_0$ and $T_1$, and
    \item user $A$ will provide ``feedback'' $f(m)$ to user $C$'s message $m$. This could be any nonempty response to $C$'s message, such as the $\ACK$ message in our system (see \cref{subsec:ACK}), or in systems without acknowledgements, a ``I'm good! How are you?'' in response to a ``Hi! How are you?''.
\end{itemize}
At time $T_0$, the malicious server stores $\ct$, and continues to serve $A$ honestly until time $T_1$. During $A$ and $C$'s conversation, the server responds to $A$'s PIR requests with $\resp = \answer^{DB'}(1^{\lambda}, \ct)$, where $DB'[i_B]$ is a valid message $m$ from $C$ to $A$, and $DB'[i] = 0$ for any $i \neq i_B$. If $\ct$ is a query to $i_B$, $A$ will receive the message from $C$ and send feedback $f(m)$ to $C$. Otherwise, $A$ will not receive a message from $C$ and not send feedback to $C$. Therefore, $C$ can observe $A$'s feedback and learn if $\ct$ is a query to $i_B$ or not.

This attack can be prevented by changing the PIR key pair each round, which increases both client-side computation and the bandwidth required, because the server can no longer cache the big Galois key used in many PIR protocols. The PIR replay attack shows that compromised friends can do more damage to MPM systems than previously known.

\textbf{Remark}: In \cite{henry2022simplepir}, Henzinger et al. discovered another attack exploiting key pair reuse. The two attacks are fundamentally different. The attack proposed in \cite{henry2022simplepir} is on the primitive level, specific to the BFV cryptosystem, and assumes the attacker has full access to the clients' PIR decryption oracles. In contrast, our attack is on the protocol level, applies to any public key homomorphic encryption system, and makes no assumption on the particular feedback the attacker gets.

%\todo{Impersonation attack is not understandable unless you know exactly how Anysphere is implemented, so I removed it}