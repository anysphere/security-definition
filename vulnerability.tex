\section{The PIR Replay Attack}
\label{sec:security-vulnerable}

In this section, we present the PIR Replay Attack mentioned in the Introduction. While the CF attacks in \cite{angel2018cf} can only reveal the number of friends each honest user has, this attack can potentially reveal the sender and recipient of a PIR request if the recipient has a compromised friend. The vulnerability affects existing implementations of both Pung and Addra.

Most PIR schemes(such as SealPIR \cite{angel2018pir}, MulPIR \cite{ali2021communicationcomputation}, FastPIR \cite{ahmad2021addra}, and Spiral \cite{wu2022spiral}) use an underlying homomorphic public key cryptosystem, typically some variation of the BFV cryptosystem \cite{fan2012somewhat}. Generating the necessary keypairs in these cryptosystems is expensive. To improve performance, real-world implementations of FastPIR and Spiral reuse PIR keys. Each client generates a secret $\sk_{\pir}$ once and use them to encrypt all PIR queries $\ct = \query(1^{\lambda}, \sk_{\pir}, i)$. This optimization was regarded safe since it preserves the UO-ER security definition in \cite[Extended Version]{angel2016unobservable}. Now we show how to combine this optimization with a compromised friend to leak metadata.

Suppose the adversary suspects that honest users $A$ and $B$ are communicating, and honest user $A$ has a compromised friend $C$. On timestep $T_0$, user $A$ sends a PIR request $\ct$ to the server. The adversary wishes to know if $\ct$ is a query to honest user $B$'s mailbox at index $i_B$. Assume that
\begin{itemize}
    \item User $A$ will have a conversation with user $C$ at a future time $T_1 > T_0$. 
    \item User $A$ does not switch PIR keypair between time $T_0$ and $T_1$.
    \item User $A$ will provide "feedback" $f(m)$ to user $C$'s message $m$. This could be any nonempty response to $C$'s message, such as the $\ACK$ message in our system (See \cref{subsec:ACK}).
\end{itemize}
At time $T_0$, the server stores $\ct$, and continues to serve $A$ honestly until time $T_1$. During $A$ and $C$'s conversation, the server responds to $A$'s PIR requests with $\resp = \answer^{DB'}(1^{\lambda}, \ct)$, where $DB'[i_B]$ is a valid message $m$ from $C$ to $A$, and $DB'[i] = 0$ for any $i \neq i_B$. If $\ct$ is a query to $i_B$, $A$ will receive the message from $C$ and send feedback to $C$. Otherwise, $A$ will not receive a message from $C$ and not send feedback to $C$. Therefore, $C$ can observe $A$'s feedback and learn if $\ct$ is a query to $i_B$ or not.

This attack can be prevented by changing the PIR keypair each round, which is ok for Anysphere because of our low client-side computation requirement. However, it shows that compromised friends can do more damage to MPM systems than previously known.

\textbf{Note}: In \cite{henry2022simplepir}, Henzinger et. al. discovered another attack exploiting keypair reuse. The two attacks are fundamentally different. The attack proposed in \cite{henry2022simplepir} is on the primitive level, specific to the BFV cryptosystem, and assumes the attacker has full access to the clients' PIR decryption oracle. In contrast, our attack is on the protocol level, applies to any public key homomorphic encryption system, and makes no assumption on the feedback the attacker gets.

%\todo{Impersonation attack is not understandable unless you know exactly how Anysphere is implemented, so I removed it}